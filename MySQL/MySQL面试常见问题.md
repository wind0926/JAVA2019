
* [MySQL面试知识点总结](#mysql面试知识点总结)
      * [MySQL的常问方式：](#mysql的常问方式：)
  * [基础部分](#基础部分)
    * [1.数据库的三大范式？](#1数据库的三大范式？)
    * [2.内连接与外连接的区别？](#2内连接与外连接的区别？)
        * [内连接（inner join） ： 只显示符合连接条件的记录。](#内连接（inner-join）-：-只显示符合连接条件的记录。)
        * [外连接分左外连接、 右外连接、 全外连接三种。](#外连接分左外连接、-右外连接、-全外连接三种。)
    * [3. 存储过程的概念以及优缺点是什么？](#3-存储过程的概念以及优缺点是什么？)
      * [优点:](#优点)
      * [缺点:](#缺点)
    * [4. 数据库事务正确执行的四个基本要素（事务的四个属性）。](#4-数据库事务正确执行的四个基本要素（事务的四个属性）。)
    * [5. 并发事务带来的问题。](#5-并发事务带来的问题。)
    * [6. 数据库事物的隔离级别介绍、举例说明。](#6-数据库事物的隔离级别介绍、举例说明。)
      * [数据库提供了 4 种隔离级别(由低到高):](#数据库提供了-4-种隔离级别由低到高)
    * [7.MySQL事务控制语句](#7mysql事务控制语句)
    * [8.truncate 与 delete 的区别是什么?](#8truncate-与-delete-的区别是什么)
        * [附：](#附：)
    * [9. select Count (\*) 和 Select Count( 数 字 ) 以 及 Select Count(column)区别.](#9-select-count--和-select-count-数-字--以-及-select-countcolumn区别)
    * [10. EXISTS 关键字的使用方法?](#10-exists-关键字的使用方法)
    * [11. 有一个学生表,有三个字段:name 、course 、score ,每一个学生都有三门课程,比如数学、语文、英语,写 sql 语句,查找出三门课程的成绩都大于 80 的学生。](#11-有一个学生表有三个字段name-、course-、score-每一个学生都有三门课程比如数学、语文、英语写-sql-语句查找出三门课程的成绩都大于-80-的学生。)
    * [12. 判断表的字段值是否为空](#12-判断表的字段值是否为空)
    * [13. 一张表,里面有 ID 自增主键,当 insert 了 17 条记录之后,删除了第 15,16,17 条记录,再把 Mysql 重启,再 insert 一条记录,这条记录的 ID 是 18 还是 15 ?](#13-一张表里面有-id-自增主键当-insert-了-17-条记录之后删除了第-151617-条记录再把-mysql-重启再-insert-一条记录这条记录的-id-是-18-还是-15-)
    * [14、MySQL 中的数据类型有哪些？](#14、mysql-中的数据类型有哪些？)
    * [15、char 和 varchar 的区别？](#15、char-和-varchar-的区别？)
    * [16、varchar(10) 和 varchar(20) 的区别？](#16、varchar10-和-varchar20-的区别？)
  * [高级部分](#高级部分)
    * [17.优化查询的方法？](#17优化查询的方法？)
      * [1.使用索引](#1使用索引)
      * [2.优化 SQL 语句](#2优化-sql-语句)
      * [3.优化数据库对象](#3优化数据库对象)
        * [3.1对表进行拆分      ](#31对表进行拆分--    )
        * [通过拆分表可以提高表的访问效率。 有 2 种拆分方法：      ](#通过拆分表可以提高表的访问效率。-有-2-种拆分方法：--    )
        * [3.2 使用中间表来提高查询速度](#32-使用中间表来提高查询速度)
      * [4.硬件优化](#4硬件优化)
    * [18. 如果有一个特别大的访问量到数据库上，怎么做优化？](#18-如果有一个特别大的访问量到数据库上，怎么做优化？)
      * [1.使用优化查询的方法（见上面）](#1使用优化查询的方法（见上面）)
      * [2.主从复制， 读写分离， 负载均衡](#2主从复制，-读写分离，-负载均衡)
        * [主从复制的原理：](#主从复制的原理：)
        * [主从复制的几种方式：](#主从复制的几种方式：)
    * [19. 数据库分表，分区，分库](#19-数据库分表，分区，分库)
      * [    对表进行拆分](#    对表进行拆分)
        * [     1.垂直拆分：](#    -1垂直拆分：)
        * [     2.水平拆分：](#    -2水平拆分：)
        * [     分区:](#    -分区)
        * [     分库:](#    -分库)
    * [20. 并发控制的方式（如何解决并发问题）。](#20-并发控制的方式（如何解决并发问题）。)
        * [乐观锁](#乐观锁)
        * [悲观锁](#悲观锁)
        * [如何锁定一行？](#如何锁定一行？)
    * [21. 如何并发访问数据库](#21-如何并发访问数据库)
        * [预防死锁](#预防死锁)
        * [避免死锁](#避免死锁)
    * [22. mysql 锁的粒度(即锁的级别)](#22-mysql-锁的粒度即锁的级别)
    * [23.索引是什么？索引能跟干什么？](#23索引是什么？索引能跟干什么？)
    * [24.索引的分类](#24索引的分类)
    * [25. 数据库索引的原理(实现)](#25-数据库索引的原理实现)
        * [InnoDB索引实现](#innodb索引实现)
        * [MyISAM 索引实现](#myisam-索引实现)
    * [26. Mysql的 B+树索引的优点?为什么不用二叉树?B-树和 B+树为什么比红黑树更合适?](#26-mysql的-b树索引的优点为什么不用二叉树b-树和-b树为什么比红黑树更合适)
    * [27.建索引的几大原则。](#27建索引的几大原则。)
    * [28. mysql 中 MyIsam 与 InnoDB 的区别,至少 5 点。](#28-mysql-中-myisam-与-innodb-的区别至少-5-点。)
    * [29.请说下你对 MySQL 架构的了解？](#29请说下你对-mysql-架构的了解？)
    * [30、一条 SQL 语句在数据库框架中的执行流程？](#30、一条-sql-语句在数据库框架中的执行流程？)
    * [31、谈谈你对 B+ 树的理解？](#31、谈谈你对-b-树的理解？)
    * [32、谈谈你对聚簇索引的理解？](#32、谈谈你对聚簇索引的理解？)
    * [33、谈谈你对哈希索引的理解？](#33、谈谈你对哈希索引的理解？)
    * [34、谈谈你对覆盖索引的认识？](#34、谈谈你对覆盖索引的认识？)
    * [35、谈谈你对最左前缀原则的理解？](#35、谈谈你对最左前缀原则的理解？)
    * [36、怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?](#36、怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因)
    * [37、什么情况下索引会失效？即查询不走索引？](#37、什么情况下索引会失效？即查询不走索引？)
    * [38、主从复制中涉及到哪三个线程？](#38、主从复制中涉及到哪三个线程？)
    * [39、主从同步的延迟原因及解决办法？](#39、主从同步的延迟原因及解决办法？)
      * [主从同步的延迟的原因：](#主从同步的延迟的原因：)
      * [主从同步延迟的解决办法：](#主从同步延迟的解决办法：)
    * [40、谈谈你对数据库读写分离的理解？](#40、谈谈你对数据库读写分离的理解？)
        * [读写分离能提高性能的原因在于：](#读写分离能提高性能的原因在于：)
    * [41、谈谈你对 MVCC 的了解？](#41、谈谈你对-mvcc-的了解？)
        * [MVCC 可以为数据库解决以下问题](#mvcc-可以为数据库解决以下问题)
    * [42、说一下 MySQL 的行锁和表锁？](#42、说一下-mysql-的行锁和表锁？)
    * [43、InnoDB 存储引擎的锁的算法有哪些？](#43、innodb-存储引擎的锁的算法有哪些？)
    * [44、MySQL 问题排查都有哪些手段？](#44、mysql-问题排查都有哪些手段？)
        * [1.开启慢查询日志，查看慢查询的 SQL。](#1开启慢查询日志，查看慢查询的-sql。)
        * [2.再根据出现问题的sql语句，使用 Explain 命令查询 SQL 语句执行计划](#2再根据出现问题的sql语句，使用-explain-命令查询-sql-语句执行计划)
        * [3.使用Show profiles](#3使用show-profiles)
    * [45、MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？](#45、mysql-数据库-cpu-飙升到-500-的话他怎么处理？)


# MySQL面试知识点总结

 

#### MySQL的常问方式：

```
(1)场景题，手写 SQL；

(2)MySQL 的相关底层原理：存储引擎、索引、锁、事务等等；

(3)查询性能优化。
```

 

 

## 基础部分

### 1.数据库的三大范式？

```
1NF:字段不可再分,原子性。      

2NF:满足第二范式( 2NF )必须先满足第一范式( 1NF )。 一个表只能说明一个事物。非主键属性必须完全依赖于主键属性。      

3NF:满足第三范式( 3NF ) 必须先满足第二范式( 2NF ) 。每 列都与主键有直接关系,不存在传递依赖。 任何非主属性不依赖于其它 非主属性。
```

 

### 2.内连接与外连接的区别？

##### 内连接（inner join） ： 只显示符合连接条件的记录。

```
SQL>select * from t1 inner join t2 on t1.id=t2.id;
```

#####  外连接分左外连接、 右外连接、 全外连接三种。

```
1） 左外连接（LEFT JOIN 或 LEFT OUTER JOIN ） 
     即以左表为基准，到右表找匹配的数据，找不到匹配的用 NULL 补齐。 
     显示左表的全部记录及右表符合连接条件的记录。 

2） 右外连接（RIGHT JOIN 或 RIGHT OUTER JOIN ）
	显示右表的全部记录及左表符合连接条件的记录。
	
3）全外连接（FULL JOIN 或 FULL OUTER JOIN） 
     除了显示符合连接条件的记录外，在 2 个表中的其他记录也显示出来。 即以右表为基准，到左表找匹配的数据，找	不到匹配的用 NULL 补齐。 
 
```

 

### 3. 存储过程的概念以及优缺点是什么？

   

```
  存储过程:就是一些编译好了的 sql 语句,这些 SQL 语句代码 像一个方法一样实现一些功能(对单表或多表的增删改查),然后 再给这个代码块取一个名字,在用到这个功能的时候调用他就行了。
```



#### 优点:

```
1.存储过程因为 SQL 语句已经预编译过了,因此运行的速度比 较快。

2.存储过程在服务器端运行,减少客户端的压力。
```



#### 缺点:

     调试麻烦(至少没有像开发程序那样容易),可移植性不灵活(因 为存储过程是依赖于具体的数据库)。

 

### 4. 数据库事务正确执行的四个基本要素（事务的四个属性）。

```
 ACID:原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、 持久性(Durability)。 
    
    原子性:一个事务(transaction)中的所有操作,要么全部完成,要么全部不完成。 
     一致性:在事务操作前后数据总量保持不变。
	隔离性:事务之间相互独立。
     持久性:一个事务一旦提交,它对数据库中数据的改变就应该是永久性的,并不会被 回滚。 

 
```



### 5. 并发事务带来的问题。

```
1.脏读:一个事务读取到另外事务的数据。

2.不可重复读:是指在一个事务内,多次读同一数据。在这个事务还没有结束时,另外一 个事务也访问该同一数据。那么,在第一个事务中的两次读数据之间,由于第 二个事务的修改,那么第一个事务两次读到的的数据可能是不一样的。这样就 发生了在一个事务内两次相同的查询读到的数据是不一样的,因此称为是不可 重复读。 

3.幻读: 目前工资为 5000 的员工有 10 人,事务 A 读取所有工资为 5000 的人数为 10 人。此时,事务 B 插入一条工资也为 5000 的记录。这是,事务 A 再次读取 工资为 5000 的员工,记录为 11 人。此时产生了幻读。
```

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/67.png) 

 

### 6. 数据库事物的隔离级别介绍、举例说明。

#### 数据库提供了 4 种隔离级别(由低到高):

这 4 个级别可逐个解决脏读,不可重复读和幻读这几个问题。

```
1.读未提交数据 
read uncommitted;

2.读已提交数据 
  read committed;

3.可重复读(Mysql 的默认隔离级别) 
  repeatable read;

4.可串行化 
    serializable;
```

```
    事务的隔离级别：
​           		 脏读    不可重复读   幻读
  read uncommitted：√        √    		√
  read committed：  ×        √    		√
  repeatable read： ×        ×    		 √
  serializable   ×       	 ×    		×

mysql中默认 第三个隔离级别 repeatable read

oracle中默认第二个隔离级别 read committed
```

 

### 7.MySQL事务控制语句

```
	set autocommit=0;
  start transaction;
  commit;
  rollback;
```

 

### 8.truncate 与 delete 的区别是什么?

```
1.truncate不能加where条件，而delete可以加where条件 
2.truncate的效率高一丢丢
3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
   delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始
4.truncate删除不能回滚，delete删除可以回滚
```

 

##### 附：

```
DELETE TABLE:删除内容、不删除定义,不释放空间。 

TRUNCATE TABLE:删除内容、不删除定义、释放空间。

DROP TABLE:删除内容和定义,释放空间。 
```

 

### 9. select Count (\*) 和 Select Count( 数 字 ) 以 及 Select Count(column)区别.

     count(*) 跟 count(1) 的结果一样,返回记录的总行数,都包括 对 NULL 的统计,而 count(column) 是不包括 NULL 的统计。

 

### 10. EXISTS 关键字的使用方法?

  EXISTS 关键字表示存在。使用 EXISTS 关键字时,内层查询语句不返回查询的记录, 而是返回一个真假值。 
     如果内层查询语句查询到符合条件的记录,就返回一个真值(true),否则,将返回 一个假值(false):

​		当返回的值为 true 时,外层查询语句将进行查询。

· 		当返回的值为 false 时,外层查询语句将不进行查询或者查询不出任何记录。



###  11. 有一个学生表,有三个字段:name 、course 、score ,每一个学生都有三门课程,比如数学、语文、英语,写 sql 语句,查找出三门课程的成绩都大于 80 的学生。

```
SELECT S.name

 FROM Student S

 GROUP BY S.name

 Having MIN(S.score)>=80
```

 

 

### 12. 判断表的字段值是否为空

```
	1、查询字段值为空的语法:where <字段名> is null 
	2、查询字段值不为空的语法:where <字段名> is not null 或者 where NoT(<字段名> 		IS NULL) 
```

 

### 13. 一张表,里面有 ID 自增主键,当 insert 了 17 条记录之后,删除了第 15,16,17 条记录,再把 Mysql 重启,再 insert 一条记录,这条记录的 ID 是 18 还是 15 ?

```
   	如果表的类型是 MyISAM,那么是 18。 
	因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里,重启 MySQL 自增主键的最大 ID 也不会丢失。 
     如果表的类型是 InnoDB,那么是 15。 
	InnoDB 表只是把自增主键的最大 ID 记录到内存中,所以重启数据 库会导致最大 ID 丢失。 
```

 

### 14、MySQL 中的数据类型有哪些？

 MySQL 中的数据类型主要有数值类型、时间/日期类型、字符串类型，如下图所示：

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/68.jpg) 

 

 

### 15、char 和 varchar 的区别？

char(n) ：固定长度类型，比如：订阅 char(10)，当你输入"abc"三个字符的时候，它们占		的空间还是 10 个字节，其他 7 个是空字节。char 优点：效率高；缺点：占用空		间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。

varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节	的长度。所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，	二者使用需要权衡。

 

### 16、varchar(10) 和 varchar(20) 的区别？

varchar(10) 中 10 的涵义最多存放 10 个字符，varchar(10) 和 varchar(20) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 order by col 采用 fixed_length 计算 col 长度。

 

 

 

 

## 高级部分

 

### 17.优化查询的方法？

#### 1.使用索引

     应尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。

#### 2.优化 SQL 语句

```
    2.1 通过 explain(查询优化神器)用来查看 SQL 语句的执行效果， 可以帮助选择更好的索引和优化查询语句， 		写出更好的优化语句。 通 常我们可以对比较复杂的,尤其是涉及到多表的 SELECT 语句， 把关 键字 			EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news; 
     2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代 替“*” ， 不要返回用不到的任何字段。 
     2.3 不在索引列做运算或者使用函数。 
     2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和 带宽浪费。
```



#### 3.优化数据库对象

##### 3.1对表进行拆分       

##### 通过拆分表可以提高表的访问效率。 有 2 种拆分方法：       

```
1.垂直拆分:把主键和一些列放在一个表中， 然后把主键和另外的列放在另 一个表中。 如果一个表中某些列常用， 而	另外一些不常用， 则可以 采用垂直拆分。       

2.水平拆分:根据一列或者多列数据的值把数据行放到二个独立的表中。  
```

##### 3.2 使用中间表来提高查询速度 

#### 4.硬件优化

```
CPU 的优化 :选择多核和主频高的 CPU。 
```

 

### 18. 如果有一个特别大的访问量到数据库上，怎么做优化？

#### 1.使用优化查询的方法（见上面）

#### 2.主从复制， 读写分离， 负载均衡

     目前，大部分的主流关系型数据库都提供了主从复制的功能，通过配置两台（或多台） 数据库的主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站可 以利用数据库的这一功能，实现数据库的读写分离，从而改善数据库的负载压力。一个系 统的读操作远远多于写操作，因此写操作发向 master，读操作发向 slaves 进行操作（简 单的轮循算法来决定使用哪个 slave）。 ![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/69.jpg)

![img](file:///C:\Users\tll\AppData\Local\Temp\ksohtml13436\wps4.png)
   ![img](file:///C:\Users\tll\AppData\Local\Temp\ksohtml13436\wps5.png)![img](file:///C:\Users\tll\AppData\Local\Temp\ksohtml13436\wps6.png) 

##### 主从复制的原理：

     影响 MySQL-A 数据库的操作，在数据库执行后，都会写入本地的日志系统 A 中。 假设，实时的将变化了的日志系统中的数据库事件操作，通过网络发给 MYSQL-B。 MYSQL-B 收到后，写入本地日志系统 B，然后一条条的将数据库事件在数据库中完成。 那么，MYSQL-A 的变化，MYSQL-B 也会变化，这样就是所谓的 MYSQL 的复制。 
     在上面的模型中，MYSQL-A 就是主服务器，即 master，MYSQL-B 就是从服务器，即 slave。 

 

##### 主从复制的几种方式：

```
1.同步复制 
    主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，必须等待验证所 有的从服务器的更新数据是否已经复制到其中，之后才可以自由处理其它进入的事务处理 请求。

2.异步复制 
    主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，无需等待验证更 新数据是否已经复制到从服务器中，就可以自由处理其它进入的事务处理请求。

3.半同步复制 
    主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，只需等待验证其 中一台从服务器的更新数据是否已经复制到其中，就可以自由处理其它进入的事务处理请 求，其他的从服务器不用管。 
```



 

### 19. 数据库分表，分区，分库

####     对表进行拆分

     通过拆分表可以提高表的访问效率。 有 2 种拆分方法： 

#####      1.垂直拆分： 

     把主键和一些列放在一个表中， 然后把主键和另外的列放在另 一个表中。 如果一个	表中某些列常用， 而另外一些不常用， 则可以 采用垂直拆分。 

#####      2.水平拆分： 

     根据一列或者多列数据的值把数据行放到二个独立的表中。 

#####      分区:

​		就是把一张表的数据分成多个区块，这些区块可以在一个磁盘上，也可以在不同 的磁盘上，分区后，表面上		还是一张表，但数据散列在多个位置，这样一来，多块硬盘同 时处理不同的请求，从而提高磁盘 I/O 读写性		能，实现比较简单。 包括水平分区和垂直分 区。 

#####      分库:

​		是根据业务不同把相关的表切分到不同的数据库中，比如 web、bbs、blog 等库。 

 

### 20. 并发控制的方式（如何解决并发问题）。

     加锁,如乐观锁和悲观锁。

##### 乐观锁

​	通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。

举例：

下单操作包括3步骤：

```
1.查询出商品信息

select (status,status,version) from t_goods where id=#{id}

2.根据商品信息生成订单

3.修改商品status为2

update t_goods 

set status=2,version=version+1

where id=#{id} and version=#{version};
```

 

##### 悲观锁

##### 如何锁定一行？

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/70.png) 

 

 

### 21. 如何并发访问数据库

    锁是一种并发控制技术,锁是用来在多个用户同时访问同一个数据的时候 保护数据的 。

产生死锁的四个必要条件:

```
(1) 互斥条件:一个资源每次只能被一个进程使用。 
(2) 请求与保持条件:一个进程因请求资源而阻塞时,对已获得的资源保持不放。 
(3) 不可剥夺条件:进程已获得的资源,在末使用完之前,不能强行剥夺。 
(4) 环路等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 
```

     只要系统发生了死锁,这些条件必然成立,而只要上述条件之一不满足,就不会发生死 锁。 

     只要系统发生了死锁,这些条件必然成立,而只要上述条件之一不满足,就不会发生死 锁。 

##### 预防死锁 

     预防死锁的发生只需破坏死锁产生的四个必要条件之一即可。 

##### 避免死锁 

     银行家算法。

 

### 22. mysql 锁的粒度(即锁的级别)

1. 表级锁,直接锁定整张表,在你锁定期间,其它进程无法对该表进行写操作。

2. 行级锁,仅对指定的记录进行加锁,这样其它进程还是可以对同一个表中的其它记 录进行操作。
3. 页级锁,一次锁定相邻的一组记录。

 

### 23.索引是什么？索引能跟干什么？

索引是帮助mysql高效获取数据的数据结构。索引非常关键，尤其当表中的数据量越来越大时，索引对于性能的影响愈发重要，可以将查询性能提升好几个数量级，总的来说可以明显的提高查询效率。你可以简单理解为"排好序的快速查找数据结构"。

 

### 24.索引的分类

```
1.从存储结构上划分：BTree索引、Hash索引、全文索引。

2.从引用层次：单值索引、唯一索引、复合索引。

	单值索引：即一个索引只包含单个列，一个表可以有多个单列索引；
	
	唯一索引：索引列的值必须唯一，但允许有空值；

	复合索引：即一个索引包含多个列。
```

 

### 25. 数据库索引的原理(实现)

     目前大部分数据库系统及文件系统都采用 B-Tree( B 树)或其变种 B+Tree (B+树)作为索引结构。B+Tree 是数据库系统实现索引的首选数据结构。      
在 MySQL 中,索引属于存储引擎级别的概念,不同存储引擎对索引的实现方式 是不同的,本文主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。

##### InnoDB索引实现

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/71.png) 

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/72.png) 

 

#####  MyISAM 索引实现

 MyISAM 引擎使用 B+Tree 作为索引结构,叶节点的 data 域存放的是数据记录 的地址。下图是 MyISAM 索引的原理图: 

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/73.jpg) 

虽然 InnoDB 也使用 B+Tree 作为索引结构,但具体实现方式却与 MyISAM 截 然不同。 
     第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道, MyISAM 索引文件和数据文件是分离的,索引文件仅保存数据记录的地址。而在 InnoDB 中,表数据文件本身就是按 B+Tree 组织的一个索引结构,这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键,因此 InnoDB 表数据文件本身就是主索引。 

 

 

### 26. Mysql的 B+树索引的优点?为什么不用二叉树?B-树和 B+树为什么比红黑树更合适?

     数据库文件很大,需要存储到磁盘上,索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。 

```
1.高度原因 
     B+树中的每个结点可以包含大量的关键字,这样树的深度降低了,所以任何关键 字的查找必须走一条从根结点到叶子结点的路,所有关键字查询的路径长度相同,导致 每一个数据的查询效率相当, 这就意味着查找一个元素只要很少结点从外存磁盘中读入 内存,很快访问到要查找的数据,减少了磁盘 I/O 的存取次数。 
2.磁盘预读原理和局部性原理 
     将一个节点的大小设为等于一个页,这样每个节点只需要一次 I/O 就可以完全载 入。
```



### 27.建索引的几大原则。

```
1.更新频繁的列不应设置索引；

2.数据量小的表不要设置索引；

3.重复数据多的字段不要设置索引（比如：性别）。

4.首先考虑对where和order by 涉及到的列建立索引。
```

 

 

### 28. mysql 中 MyIsam 与 InnoDB 的区别,至少 5 点。

     Mysql 数据库中,最常用的两种引擎是 innordb 和 myisam。InnoDB 是 Mysql 的默 认存储引擎。 

```
1.事务处理上方面 
    MyISAM 强调的是性能,查询的速度比 InnoDB 类型更快,但是不提供事务支持。 
     InnoDB 提供事务支持事务。 

2.外键 
     MyISAM 不支持外键,InnoDB 支持外键。 

3.锁 
     MyISAM 只支持表级锁,InnoDB 支持行级锁和表级锁,默认是行级锁,行锁大幅 度提高了多用户并发操作的性能。innodb 比较适合于插入和更新操作比较多的情况, 而 myisam 则适合用于频繁查询的情况。另外,InnoDB 表的行锁也不是绝对的,如果 在执行一个 SQL 语句时,MySQL 不能确定要扫描的范围,InnoDB 表同样会锁全表, 例如 update table set num=1 where name like “%aaa%”。 

4.全文索引 
     MyISAM 支持全文索引, InnoDB 不支持全文索引。innodb 从 mysql5.6 版本开始提 供对全文索引的支持。 

5.表主键 
     MyISAM:允许没有主键的表存在。 
     InnoDB:如果没有设定主键,就会自动生成一个 6 字节的主键(用户不可见)。 

6.表的具体行数 
     MyISAM:select count() from table,MyISAM 只要简单的读出保存好的行数。因为 MyISAM 内置了一个计数器,count()时它直接从计数器中读。 
     InnoDB: 
不保存表的具体行数,也就是说,执行 select count(*) from table 时, InnoDB 要扫描一遍整个表来计算有多少行。

 
```



 

### 29.请说下你对 MySQL 架构的了解？

先看下 MySQL 的基本架构图：

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/74.jpg)![img](file:///C:\Users\tll\AppData\Local\Temp\ksohtml13436\wps12.png) 

​	大体来说，MySQL 可以分为 Server 层和存储引擎两部分。Server 层包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。存储引擎层负责：数据的存储和提取。其架构是插件式的，支持 InnoDB、MyISAM 等多个存储引擎。从 MySQL5.5.5 版本开始默认的是InnoDB，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。不同存储引擎的表数据存取方式不同，支持的功能也不同。从上图中可以看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。

 

 

### 30、一条 SQL 语句在数据库框架中的执行流程？

```
1.应用程序把查询 SQL 语句发送给服务器端执行；

2.查询缓存，如果查询缓存是打开的，服务器在接收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相对应的查询数据，如果存在，则直接返回给客户端。只有缓存不存在时，才会进行下面的操作；

3.查询优化处理，生成执行计划。这个阶段主要包括解析 SQL、预处理、优化 SQL 执行计划；

4.MySQL 根据相应的执行计划完成整个查询；

5.将查询结果返回给客户端。
```

 

### 31、谈谈你对 B+ 树的理解？

```
1.B+ 树是基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。

2.在 B+ 树中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key i 和 key i+1，且不为 null，则该指针指向节点的所有 key 大于等于 key i 且小于等于 key i+1。

3.进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

4.插入、删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。
```

 

### 32、谈谈你对聚簇索引的理解？

聚簇索引将索引和数据行保存在同一个B-Tree中，查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高。

聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的，

非聚簇索引，又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。

 

### 33、谈谈你对哈希索引的理解？

哈希索引能以 O(1) 时间进行查找，但是失去了有序性。无法用于排序与分组、只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如：快速的哈希查找。

 

### 34、谈谈你对覆盖索引的认识？

如果一个索引包含了满足查询语句中字段与条件的数据就叫做覆盖索引。具有以下优点：

```
1.索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
2.一些存储引擎（例如：MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
3.对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。
```

 

### 35、谈谈你对最左前缀原则的理解？

如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/75.png) 

 

### 36、怎么知道创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因?

使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possilbe_key、key、key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。

 

### 37、什么情况下索引会失效？即查询不走索引？

下面列举几种不走索引的 SQL 语句：

```
1.索引列参与表达式计算：

SELECT 'sname' FROM 'stu' WHERE 'age' + 10 = 30;

2.函数运算：

SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) < 1990; 

3.%词语%--模糊查询：

SELECT * FROM 'manong' WHERE `uname` LIKE '码农%' -- 走索引
SELECT * FROM 'manong' WHERE `uname` LIKE "%码农%" -- 不走索引

4.字符串与数字比较不走索引：

CREATE TABLE 'a' ('a' char(10)); EXPLAIN SELECT * FROM 'a' WHERE 'a'="1" -- 走索引

EXPLAIN SELECT * FROM 'a'WHERE 'a'=1 **-- 不走索引，同样也是使用了函数运算** 

5.查询条件中有 or ，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引：

select * from dept where dname='xxx' or loc='xx' or deptno = 45;

6.正则表达式不使用索引。

7.MySQL 内部优化器会对 SQL 语句进行优化，如果优化器估计使用全表扫描要比使用索引快，则不使用索引。

8.is null,is not null 也无法使用索引
```

 

 

### 38、主从复制中涉及到哪三个线程？

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

1.binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。

2.I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）	中。

3.SQL 线程 ：负责读取重放日志并重放其中的 SQL 语句。

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/76.jpg) 

 

### 39、主从同步的延迟原因及解决办法？

#### 主从同步的延迟的原因：

假如一个服务器开放 Ｎ 个连接给客户端，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个， 当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL 要进行锁表就会导致主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。

#### 主从同步延迟的解决办法：

实际上主从同步延迟根本没有什么一招制敌的办法， 因为所有的 SQL 必须都要在从服务器里面执行一遍，但是主服务器如果不断的有更新操作源源不断的写入，那么一旦有延迟产生，那么延迟加重的可能性就会原来越大。当然我们可以做一些缓解的措施。

```
1.我们知道因为主服务器要负责更新操作， 它对安全性的要求比从服务器高，所有有些设置可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而 slave 则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭 binlog、innodb_flushlog、innodb_flush_log_at_trx_commit 也 可以设置为 0 来提高 SQL 的执行效率。
2.增加从服务器，这个目的还是分散读的压力， 从而降低服务器负载。
```

 

### 40、谈谈你对数据库读写分离的理解？

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

##### 读写分离能提高性能的原因在于：

```
1.主从服务器负责各自的读和写，极大程度缓解了锁的争用；

2.从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；

3.增加冗余，提高可用性。

```

 

### 41、谈谈你对 MVCC 的了解？

数据库并发场景：

```
1.读-读：不存在任何问题，也不需要并发控制；

2.读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读；

3.写-写：有线程安全问题，可能会存在更新丢失问题。
```

多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事	务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读	操作只读该事务开始前的数据库的快照。 

##### MVCC 可以为数据库解决以下问题

```
1.在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能；

2.同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。
```

 

### 42、说一下 MySQL 的行锁和表锁？

MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。

行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。



### 43、InnoDB 存储引擎的锁的算法有哪些？

```
1.Record lock：单个行记录上的锁；

2.Gap lock：间隙锁，锁定一个范围，不包括记录本身；

3.Next-key lock：record+gap 锁定一个范围，包含记录本身。
```

 

### 44、MySQL 问题排查都有哪些手段？

##### 1.开启慢查询日志，查看慢查询的 SQL。

运用日志分析工具mysqldumpslow，命令：

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/77.png)![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/78.png) 

##### 2.再根据出现问题的sql语句，使用 Explain 命令查询 SQL 语句执行计划

命令：Explain+SQL语句

![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/79.jpg) 

主要查看type字段：

显示查询使用了何种类型

从最好到最差依次是：

```
system>const>eq_ref>ref>range>index>ALL
```

 

key字段：

实际使用的索引。如果为null则没有使用索引

查询中若使用了覆盖索引，则索引和查询的select字段重叠

 

##### 3.使用Show profiles

 ![img](https://github.com/wind0926/JAVA2019/blob/master/image/Java%E5%9F%BA%E7%A1%80/GitHub%E5%9B%BE%E7%89%87/MySQL/80.png)



 

### 45、MySQL 数据库 CPU 飙升到 500% 的话他怎么处理？

```
1.列出所有进程 show processlist，观察所有进程，多秒没有状态变化的(干掉)；

2.查看超时日志或者错误日志 (一般会是查询以及大批量的插入会导致 CPU与 I/O 上	涨，当然不排除网络状态突然断了，导致一个请求服务器只接受到一半。
```

 
